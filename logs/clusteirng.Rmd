---
title: "Clustering"
author: "Dennis Scheper"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = 'C:/Users/Dennis/Desktop/internship_acutelines')
```

# Overview

# Setup

```{r, eval=F}
library(sva)
library(DESeq2)
library(dplyr)
library(tidyverse)
library(factoextra)
library(cluster)
library(ConsensusClusterPlus)
library(dendextend)
library(glue)
library(NbClust)
library(gridExtra)
library(knitr)
library(kableExtra)
library(caret)
library(ggalluvial)

source('scripts/helper_functions.R')

meta.data <- read.csv('data/source/GSE185263_meta_data_N392.csv') %>%
  mutate(mortality = ifelse(is.na(mortality), 'unknown', mortality))

# Split data into groups
meta.sepsis <- meta.data %>%
  filter(substr(sample_identifier, 1, 2) != "hc" & !patient_location %in% c("icu", 'ward'))
icu_group <- meta.data %>%
  filter(patient_location %in% c("icu", 'ward'))

load_counts <- function(path, var, meta, type) {
  counts <- read.csv(path) %>%
    column_to_rownames(var)
  
  if (type == 'icu') {
    counts <- counts %>%
      select(all_of(icu_group$sample_identifier))
  } else {
    counts <- counts %>%
      select(!all_of(icu_group$sample_identifier))
  }
  
  reordered(meta, counts)
}

fivety.counts <- load_counts('fivety.csv', 'X', meta.sepsis, 'er')
hunderd.counts <-  load_counts('hunderd.csv', 'X', meta.sepsis, 'er')
counts <- load_counts('data/de_res/res_sepsis_all.csv', 'gene', meta.sepsis, 'er')

calculate_mad <- function(count_data){
  mad.calc <- apply(count_data, 1, mad)
  mad.list <- lapply(c(0.25, 0.50, 0.75, 1), function(x){
    count_data %>%
      bind_cols(mad = mad.calc) %>%
      slice_max(n = ceiling(nrow(count_data) * x), order_by = mad) %>%
      select(-mad) %>%
      t()
  })
  return(mad.list)
}

mad.list <- calculate_mad(counts)
```

```{r}
library(factoextra)
library(NbClust)
# fix the functions
fviz_nbclust <- function (x, FUNcluster = NULL, method = c("silhouette", "wss", 
                                           "gap_stat"), diss = NULL, k.max = 10, nboot = 100, verbose = interactive(), 
          barfill = "steelblue", barcolor = "steelblue", linecolor = "steelblue", 
          print.summary = TRUE, ...) 
{
  set.seed(123)
  if (k.max < 2) 
    stop("k.max must bet > = 2")
  method = match.arg(method)
  if (!inherits(x, c("data.frame", "matrix")) & !("Best.nc" %in% 
                                                  names(x))) 
    stop("x should be an object of class matrix/data.frame or ", 
         "an object created by the function NbClust() [NbClust package].")
  if (inherits(x, "list") & "Best.nc" %in% names(x)) {
    best_nc <- x$Best.nc
    if (any(class(best_nc) == "numeric") ) 
      print(best_nc)
    else if (any(class(best_nc) == "matrix") )
      .viz_NbClust(x, print.summary, barfill, barcolor)
  }
  else if (is.null(FUNcluster)) 
    stop("The argument FUNcluster is required. ", "Possible values are kmeans, pam, hcut, clara, ...")
  else if (!is.function(FUNcluster)) {
    stop("The argument FUNcluster should be a function. ", 
         "Check if you're not overriding the specified function name somewhere.")
  }
  else if (method %in% c("silhouette", "wss")) {
    if (is.data.frame(x)) 
      x <- as.matrix(x)
    if (is.null(diss)) 
      diss <- stats::dist(x)
    v <- rep(0, k.max)
    if (method == "silhouette") {
      for (i in 2:k.max) {
        clust <- FUNcluster(x, i, ...)
        v[i] <- .get_ave_sil_width(diss, clust$cluster)
      }
    }
    else if (method == "wss") {
      for (i in 1:k.max) {
        clust <- FUNcluster(x, i, ...)
        v[i] <- .get_withinSS(diss, clust$cluster)
      }
    }
    df <- data.frame(clusters = as.factor(1:k.max), y = v, 
                     stringsAsFactors = TRUE)
    ylab <- "Total Within Sum of Square"
    if (method == "silhouette") 
      ylab <- "Average silhouette width"
    p <- ggpubr::ggline(df, x = "clusters", y = "y", group = 1, 
                        color = linecolor, ylab = ylab, xlab = "Number of clusters k", 
                        main = "Optimal number of clusters")
    if (method == "silhouette") 
      p <- p + geom_vline(xintercept = which.max(v), linetype = 2, 
                          color = linecolor)
    return(p)
  }
  else if (method == "gap_stat") {
    extra_args <- list(...)
    gap_stat <- cluster::clusGap(x, FUNcluster, K.max = k.max, 
                                 B = nboot, verbose = verbose, ...)
    if (!is.null(extra_args$maxSE)) 
      maxSE <- extra_args$maxSE
    else maxSE <- list(method = "firstSEmax", SE.factor = 1)
    p <- fviz_gap_stat(gap_stat, linecolor = linecolor, 
                       maxSE = maxSE)
    return(p)
  }
}

.viz_NbClust <- function (x, print.summary = TRUE, barfill = "steelblue", 
          barcolor = "steelblue") 
{
  best_nc <- x$Best.nc
  if (any(class(best_nc) == "numeric") )
    print(best_nc)
  else if (any(class(best_nc) == "matrix") ) {
    best_nc <- as.data.frame(t(best_nc), stringsAsFactors = TRUE)
    best_nc$Number_clusters <- as.factor(best_nc$Number_clusters)
    if (print.summary) {
      ss <- summary(best_nc$Number_clusters)
      cat("Among all indices: \n===================\n")
      for (i in 1:length(ss)) {
        cat("*", ss[i], "proposed ", names(ss)[i], 
            "as the best number of clusters\n")
      }
      cat("\nConclusion\n=========================\n")
      cat("* According to the majority rule, the best number of clusters is ", 
          names(which.max(ss)), ".\n\n")
    }
    df <- data.frame(Number_clusters = names(ss), freq = ss, 
                     stringsAsFactors = TRUE)
    p <- ggpubr::ggbarplot(df, x = "Number_clusters", 
                           y = "freq", fill = barfill, color = barcolor) + 
      labs(x = "Number of clusters k", y = "Frequency among all indices", 
           title = paste0("Optimal number of clusters - k = ", 
                          names(which.max(ss))))
    return(p)
  }
}
# assign them to the factoextra namespace
environment(fviz_nbclust) <- asNamespace("factoextra")
assignInNamespace("fviz_nbclust",fviz_nbclust,"factoextra")
environment(.viz_NbClust) <- asNamespace("factoextra")
assignInNamespace(".viz_NbClust",.viz_NbClust,"factoextra")
```

# Baseline performance

## Hierarchical clustering
```{r}
dist_hc <- dist(mad.list[[4]])

hc <- hclust(dist_hc)

plot(as.dendrogram(hc))
```


## K-means
```{r}
kmeans.wss <- function(df, k) {
  res <- kmeans(x = df, k, iter.max = 100, nstart = 10)$tot.withinss
  return(res)
}

kmeans_clusters <- 2:10
kmeans_res <- lapply(kmeans_clusters, function(x) kmeans.wss(mad.list[[4]], x))

ggplot(mapping = aes(x=kmeans_clusters, y=unlist(kmeans_res))) +
  geom_line() + 
  geom_point() +
  labs(x='Number of clusters', y='Total within clusters sum of squares') +
  geom_hline(yintercept=unlist(kmeans_res), linetype='dashed', col = 'grey') +
  ggtitle('K-Means result of WSS on all genes with 2-10 clusters')
```

## K-medoids (PAM)
```{r}
pam.wss <- function(df, k, method='euclidean') {
  res <- pam(df, k, diss=F, keep.diss = TRUE, metric=method) 
  
  return(list(res = res, av_sil_with = res$silinfo$avg.width))
}

pam.clusters <- 2:10
pam.res <- lapply(pam.clusters, function(cluster) pam.wss(mad.list[[4]], cluster))
av_sil <- lapply(pam.res, function(x) x$av_sil_with) %>% unlist()

plot(pam.res[[1]]$res)

ggplot(mapping = aes(x = pam.clusters, y = av_sil)) +
  geom_line() + 
  geom_point() +
  labs(x='Number of clusters', y='Total within clusters sum of squares') +
  ggtitle('K-Medoids (PAM) result of WSS on all genes with 2-10 clusters')
```
# Different clusters with baseline parameters

```{r}
# Evaluate amount of clusters!
evaluate_clusters <- function(clust.method, mad, distance = 'euclidean', linkage_method = NULL) {
  
  # Specify parameters depending on clust.method
  if (clust.method == 'hc') {
    nb_arguments <- list(distance = distance, method = linkage_method)
    arguments <- list(FUN = hcut, hc_func = 'agnes', hc_metric = distance, hc_method = linkage_method)
  } else if (clust.method == 'pam') {
    arguments <- list(FUN = pam, metric = distance)
  } else {
    nb_arguments <- list(distance = distance, method = clust.method)
    arguments <- list(FUN = kmeans)
  }
  
  length_mad <- (1:length(mad))/length(mad)*100
  
  mapply(function(gene_set, number) {
    arguments$x <- gene_set
    
    res <- lapply(c('wss', 'silhouette', 'gap_stat'), function(method) {
      arguments$method <- method
      res <- do.call("fviz_nbclust", args = arguments) + ggtitle(glue("{str_to_title(method)}"))
    })

    if (clust.method != "pam") {
      nb_arguments$data <- gene_set
      nb_arguments$min.nc <- 2
      nb_arguments$max.nc <- 5

      nb <- do.call("NbClust", args = nb_arguments)
      p4 <- fviz_nbclust(nb) + ggtitle("NbClust")
      poster <- gridExtra::grid.arrange(res[[1]], res[[2]], res[[3]], p4, 
                                        top = glue('Optimal number of clusters for {clust.method} ({number}% of genes)', ncol=4))
    } else {
      poster <- gridExtra::grid.arrange(res[[1]], res[[2]], res[[3]], 
                                        top = glue('Optimal number of clusters for K-medoids ({number}% of genes)'), ncol=3)
    }}, mad, length_mad)
}
```

```{r}
hc_base <- evaluate_clusters('hc', mad.list, linkage_method = 'complete')
```

```{r}
kmeans_base <- evaluate_clusters('kmeans', mad.list)
```


```{r}
pam_base <- evaluate_clusters('pam', mad.list)
```
# Optimizalization of clustering methods

```{r}
best_hclustering_method <- function(gene.df, dist.method = 'euclidean', cor = F, 
                                    cor.method = 'pearson', 
                                    pca = F, pov = 80, pcs = 0) {
  if (pca) {
    gene.df <- perform_pca(gene.df)
    if (pov != 0 & pcs == 0) {
      n_components <- explain_variance(gene.df$eigenvalues$p_cum)
      gene.df <- gene.df$pca$x[1:n_components, ]
    } else if (pov == 0 & pcs != 0) {
      gene.df <- gene.df$pca$x[1:pcs, ]
    } else {
      if (pov == 0 & pcs == 0) {
        stop("Both pov and pcs cannot be zero at the same time.")
      } else {
        stop("When using PCA, make sure either pov or pcs is set to zero.")
      }
    }
  }
  if (cor) {
    dist.mat <- as.dist((1 - cor(t(gene.df), method = cor.method)) / 2) # -1 to 1
  }
  if (cor == F) {
    dist.mat <- dist(gene.df, method = dist.method)
  }
  mets <- c('single', 'average', 'ward', 'complete', 'weighted')
  
  res.agnes <- lapply(mets, function(x) 
    agnes(dist.mat, method = x)$ac
  )
  
  res.diana <- diana(dist.mat)$dc

  names(res.agnes) <- mets
  
  return(list(agnes = res.agnes, diana = res.diana))
}

make_table_hc <- function(data, generate_table=TRUE) {
  res <- data %>% 
    unlist() %>% 
    as.data.frame() %>%
    rownames_to_column("method") %>%
    separate(method, into = c('distance', 'clustering', 'linkage')) %>%
    mutate(linkage = ifelse(is.na(linkage), 'diana', linkage)) %>%
    rename(score = last_col()) %>%
    select(-clustering)
  
  if(generate_table) {
    kable(res, format = 'latex', booktabs=T) %>%
    kable_styling(latex_options = c('scale_down')) %>%
    row_spec(which(res$score > 0.8), bold = T, color = 'white', background = 'red')
  }
  
  return(res)
}

dist_meths <- c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski")
res <- lapply(dist_meths, function(x) best_hclustering_method(mad.list[[4]], x))
names(res) <- dist_meths
    
make_table_hc(res)

cor_meths <- c("pearson", "kendall", "spearman")
res_cor <- lapply(cor_meths, function(x) 
  best_hclustering_method(mad.list[[4]], cor = T, cor.method = x))
names(res_cor) <- cor_meths

max_complete <- agnes(dist(mad.list[[4]], 'maximum'), method = 'complete')
diana_max <- diana(dist(mad.list[[4]], 'maximum'))

lapply(c('diana_max', 'max_complete'), function(scenario){
  clusters <- cutree(get(scenario), k = 2)
  fviz_cluster(list(data = mad.list[[4]], clusters = clusters), geom = 'point', ellipse.type = 'convex')
})
```

```{r}
ward_linkage <- mapply(function(method, k) {
  if (method %in% cor_meths) {
     distances <- as.dist((1 - cor(t(mad.list[[4]]), method = method) / 2))
  } else {
    distances <- dist(mad.list[[4]], method = method)
  }
  ag <- agnes(distances, method = 'ward')
  clusters <- cutree(ag, k = k)
  
  grid.arrange(top = glue("{method} with k = {k}"),
  fviz_cluster(list(data = mad.list[[4]], clusters = clusters), geom = 'point', ellipse.type = 'convex'),
  fviz_silhouette(silhouette(clusters, distances), print.summary = F), ncol=2)
}, c('maximum', 'manhattan', 'euclidean', 'pearson', 'kendall', 'spearman'), rep(2:3, 6))
```

```{r}
euclidean_clust <- agnes(dist(mad.list[[4]], 'euclidean'), method = 'ward')
dend_euclidean <- as.hclust(euclidean_clust)
plot(color_branches(dend_euclidean, k = 2), leaflab="none") # no labels

manhattan_clust <- agnes(dist(mad.list[[4]], 'manhattan'), method = 'ward')
dend_manhattan <- as.hclust(euclidean_clust)
plot(color_branches(dend_manhattan, k = 2), leaflab="none") # no labels

tanglegram(as.dendrogram(manhattan_clust), as.dendrogram(euclidean_clust))
```

```{r}
pam.res <- lapply(pam.clusters, function(cluster) 
  pam.wss(mad.list[[4]], cluster, method = 'manhattan'))
av_sil <- lapply(pam.res, function(x) x$av_sil_with) %>% unlist()

plot(pam.res[[1]]$res)
plot(pam.clusters, av_sil, type = "o", pch = 19, 
     xlab = "Number of clusters",
     ylab = "Average silhouette score", 
     main = "K-Medoids (PAM) result of WSS on all genes with 2-10 clusters", 
     col = "blue")
```

# Revisting cluster with optimized parameters
```{r}
hc_optimized <- evaluate_clusters('hc', linkage_method = 'ward.D2', distance = 'euclidean', mad.list)
```

```{r}
pam_optimized <- evaluate_clusters('pam', distance = 'manhattan', mad.list)
```

```{r}
final.pam.e <- pam(mad.list[[4]], metric = 'euclidean', k = 2)
final.pam.m <- pam(mad.list[[4]], metric = 'manhattan', k = 2)

grid.arrange(fviz_cluster(final.pam.e, data = mad.list[[4]], geom = 'point'),
             fviz_cluster(final.pam.m, data = mad.list[[4]], geom = 'point'))

grid.arrange(fviz_silhouette(final.pam.e, print.summary = F), fviz_silhouette(final.pam.m, print.summary = F))
```

```{r}
within_clusters <- function(clustering_method, meta, thres, return_res=F) {
  scores <- silhouette(clustering_method) %>%
    as.data.frame() %>%
    filter(sil_width <= thres) %>%
    rownames_to_column('sample_identifier') %>%
    inner_join(meta, by = 'sample_identifier') %>%
    group_by(cluster, sepsis_severity) %>%
    summarize(count = n()) %>%
    mutate(percentage = count/sum(count)*100)
  
  if (return_res) {
    return(scores)
  }
  
  ggplot(scores, 
         aes(x = cluster, y = percentage, fill = sepsis_severity)) +
    geom_bar(stat = "identity", position = "fill") +
    labs(y = "Percentage", x = "Clusters", fill = "Severity") +
    ggtitle(glue("Overlap between clusters based on sepsis severity (threshold = {thres})"))
} 

within_clusters(final.pam.m, meta.sepsis, 0.05)
```

```{r}
names(mad.list) <- c('25.procent', '50.procent', '75.procent', '100.percent')

consensus_res <- mapply(function(x, name) {
  x <- t(x)
  hc <- ConsensusClusterPlus(x, distance = 'euclidean', 
                             maxK = 10, reps = 1000, 
                             title = glue("Hierarchical Clustering on {name} with Euclidean and Ward.D2"), 
                             clusterAlg = "hc", innerLinkage="ward.D2", finalLinkage="ward.D2", plot = 'png')
  kmeans <- ConsensusClusterPlus(x, distance = 'euclidean',maxK = 10, reps = 1000,
                            title = glue("K-means clustering on {name} with Euclidean"), 
                            clusterAlg = "km", plot = 'png')
  pam <- ConsensusClusterPlus(x, distance = 'manhattan', maxK = 10, reps = 1000, 
                            title = glue("PAM (K-medoids) clustering on {name} with Manhattan"),
                            clusterAlg = "pam", plot = 'png')
  
  return(list(hc = hc, kmeans = kmeans, pam = pam))},  mad.list, names(mad.list))

ConsensusClusterPlus::calcICL(consensus_res[, 4]$hc)
```

```{r}
final.kmeans <- kmeans(mad.list[[4]], centers = 2, iter.max = 100, nstart = 10)

fviz_cluster(final.kmeans, mad.list[[4]], geom = 'point', ellipse.type = 'convex')
distances <- dist(mad.list[[4]])
fviz_silhouette(silhouette(final.kmeans$cluster, distances))

generate_clusters <- function(hc_clusters, pam_clusters, kmeans_clusters, meta) {
  kmeans.clusters <- kmeans_clusters$cluster %>%
    as.data.frame() %>%
    rownames_to_column('sample_identifier')
  pam.clusters <- pam_clusters$clustering %>% 
    as.data.frame() %>%
    rownames_to_column('sample_identifier')
  hc.clusters <- cutree(hc_clusters, k = 2)
  
  result <- as.data.frame(hc.clusters) %>%
    rownames_to_column('sample_identifier') %>%
    rename(hc.clusters = hc.clusters) %>%
    left_join(kmeans.clusters, by = 'sample_identifier') %>%
    left_join(pam.clusters, by = 'sample_identifier') %>%
    mutate(hc.clusters = as.factor(hc.clusters),
          kmeans.clusters = as.factor(..x),
          pam.clusters = as.factor(..y)) %>%
    select(-..x, -..y) %>%
    mutate_all(~(case_when(
      . == '1' ~ 'one',
      . == '2' ~ 'two',
      TRUE ~ .
    )))
  
  return(result)
}
cluster_groups <- generate_clusters(dend_euclidean, final.pam.m, final.kmeans)
```

```{r}
meta.sepsis <- meta.sepsis %>%
  left_join(cluster_groups, by = 'sample_identifier')

pca_res <- perform_pca(counts)

pca_scores <- pca_res$pca$x %>%
  as_tibble(rownames = 'sample_identifier') %>%
  full_join(x = ., y = meta.sepsis, by = 'sample_identifier')


lapply(c('pam.clusters', 'hc.clusters', 'kmeans.clusters'), function(method){
  pca_scores %>%
    ggplot(aes(x = PC1, y = PC2, color = !!sym(method), shape = sepsis_severity)) +
    geom_point() +
    labs(title = glue("PCA on Sepsis Population ({method})"), color = glue("{method}-based cluster"))
})
```

```{r}
ggplot(meta.sepsis, aes(axis1 = pam.clusters, axis2 = hc.clusters, axis3=kmeans.clusters)) +
  geom_alluvium(aes(fill = hc.clusters)) +
  geom_stratum(show.legend = F) +
  geom_flow() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  theme(legend.position = 'none') +
  labs(title = "Alluvium for sepsis severity and cluster groups")+
  facet_wrap(~ sepsis_severity, scales = "free_y") +
  scale_x_discrete(limits = c("PAM", "HC", "Kmeans"))

ggplot(meta.sepsis, aes(axis1 = pam.clusters, axis2 = hc.clusters, axis3=kmeans.clusters)) +
  geom_alluvium(aes(fill = sepsis_severity)) +
  geom_stratum() +
  geom_flow() +
  theme(legend.position = 'none') +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  labs(title = "Alluvium for sepsis severity and cluster groups")+
  scale_x_discrete(limits = c("PAM", "HC", "Kmeans"))
```

```{r}
calculate_similarity <- function(col1, col2) {
  sum(col1==col2)/length(col1)*100
}

all_clusters <- cluster_groups %>%
  select(-sample_identifier)

pairs <- combn(colnames(all_clusters),2 , simplify = FALSE)

similarity <- lapply(pairs, function(x) {
  similarity_percentage <- calculate_similarity(all_clusters[[x[1]]], all_clusters[[x[2]]]) %>%
    data.frame(comparison = glue("{x[1]}-{x[2]}"), sim = .)
}) %>% bind_rows() 

kable(similarity, booktabs = T, format='latex') %>%
  kable_styling()
```


```{r}
test_significance <- function(df, target) {
  
  # Clean dataset
  zero_var_cols <- nearZeroVar(df, names=TRUE)
  
  df_cleaned <- df %>%
    select(-all_of(zero_var_cols)) %>%
    select(-c("GEO_identifier", "sample_identifier_raw")) %>%
    column_to_rownames("sample_identifier") %>%
    # Mutate columns with 0/1 to categorical
    mutate(across(where(~ all(. %in% c(0, 1, NA))), as.factor))
  
  # nrows per group before NA removal in wrapper
  nrows_group <- df_cleaned %>%
    group_by(!!sym(target)) %>%
    reframe(n = n())
  
  # Wrapper function
  wrapper <- function(column, target) {
    # Temp dataframe, consisting of column and the target (kmeans clusters)
    tmp <- data.frame(col = column, tar = target) %>%
      filter(!is.na(col))
    
    if (is.numeric(tmp$col)) {
      method <- "wilcox.test"
      p.value <- wilcox.test(tmp$col ~ tmp$tar)$p.value
      
      stats <- tmp %>%
        # Group by target
        group_by(tar) %>%
        reframe(mean_value = mean(col),
                sd_value = sd(col),
                # Available in group (without NA)
                av = n()) %>%
        mutate(perc = av/nrows_group$n[cur_group_rows()] * 100,
               av_tot = nrows_group$n[cur_group_rows()])
      
      return(list(stats = stats, p.value = p.value, method = method))
      
    } else if (is.factor(tmp$col) | is.character(tmp$col)) {
      method <- "chi"
      p.value <- chisq.test(tmp$tar, as.factor(tmp$col))$p.value
      
      stats <- tmp %>%
        group_by(tar) %>%
        reframe(av = n()) %>%
        mutate(perc = av/nrows_group$n[cur_group_rows()] * 100,
               av_tot = nrows_group$n[cur_group_rows()])
      
      return(list(stats = stats, p.value = p.value, method = method))
    } else {
      print(glue("Working on {column} with target {target}"))
      stop('Something went wrong!')
    }
  }
  
  # Perform the statistical tests
  stat_tests <- df_cleaned %>%
    select(-target) %>%                                           # Remove target
    map(~ wrapper(., df_cleaned[, target])) %>%                   # Perform test on any other column
    bind_rows(.id="col_name") %>%                                 # Collapse based on column name
    tidyr::unnest(cols = stats) %>%                               # Collapse inner list (stats) to individual columns
    mutate(padj = p.adjust(p.value, method="BH")) %>%             # Post-hoc correction with BH
    filter(padj < 0.05) %>%                                       # Only keep significant columns
    arrange(desc(padj)) %>%
    rename(group = tar)
  
  return(stat_tests)
}

hc_sig <- test_significance(meta.sepsis, 'hc.clusters')
kmeans_sig <- test_significance(meta.sepsis, 'kmeans.clusters')
pam_sig <- test_significance(meta.sepsis, 'pam.clusters')

make_table <- function(df, method, csv=F) {
  table <- df %>%
    group_by(col_name, group) %>%
    mutate(elements = ifelse(is.na(mean_value),
                      glue("{round(perc, 2)}% ({av}/{av_tot})"),
                      glue("{round(mean_value, 2)} +/- {round(sd_value, 2)} ({av})"))) %>%
    ungroup() %>%
    mutate(Parameter = str_to_title(gsub("_", " ", col_name))) %>%
    select(-c(perc, av, mean_value, sd_value, col_name, av_tot)) %>%
    pivot_wider(names_from = "group", values_from = "elements") %>%
    # Change order
    select(Parameter, 'one', 'two', padj) %>%
    kable("latex", booktabs = TRUE,escape = FALSE,
          caption = glue("Significant Variables for Cluster Groups ({method})")) %>%
    kable_paper(font_size = 10)
    add_header_above(c(" " = 1, "Cluster Groups" = 2))
  
  if (csv) {
    write.csv(., glue::glue("data/tables/significant_vars_{method}.csv"), sep = ",", row.names = F,quote = F)
  }
  
  return(table)
}

make_table(pam_sig, 'PAM')
```

```{r}
generate_distributions <- function(meta, sig_vars, target, type, print_res=T) {
  selected_columns <- meta %>%
    select(all_of(c(sig_vars$col_name, target, 'sepsis_severity')))
  
  labels <- colnames(selected_columns)
  if(type == 'icu') {
    boxplot_colors <- c('orange', 'blue') 
  } else {
    boxplot_colors <- c('green', 'purple')
  }
  
  for (i in 1:length(selected_columns)) {
    column <- selected_columns[[i]]
    
    if (is.factor(column) || is.character(column)) {
      p <- ggplot(selected_columns, aes(x = !!sym(target), fill = column)) +
          geom_histogram(position = "identity", stat = 'count') +
          labs(x = glue("Cluster ({target})"), fill = glue("{labels[i]}")) +
          ggtitle(glue("Histogram of {labels[i]} per {target}"))
    } else if(is.numeric(column)) {
      p <- ggplot(selected_columns, aes(x = !!sym(target), y = column,
                                        fill = !!sym(target))) +
        geom_boxplot() +
        scale_fill_manual(values = boxplot_colors) +
        labs(x = glue("Cluster ({target})"), y = glue("{labels[i]}")) +
        ggtitle(glue("Boxplot of {labels[i]} per {target}"))
    } else {
      print(glue('Something went wrong. 
            Either you did not put in the right dataframes or 
            the target was not in the dataframe. Used target: {target}'))
    }
    if (print_res) {
      print(p)
    }
  }
}

generate_distributions(meta.sepsis, pam_sig, 'pam.clusters', 'er')
```

```{r}
plot_percentage_bar <- function(meta, cluster_group, other_var) {
  percentages <- meta %>%
    group_by(!!sym(cluster_group), !!sym(other_var)) %>%
    summarize(count = n()) %>%
    mutate(percentage = count/sum(count))
  
  ggplot(percentages, aes(x = !!sym(cluster_group), 
                          y = percentage, fill = !!sym(other_var))) +
    geom_bar(stat = "identity", position = "fill") +
    labs(y = "Percentage", x = "Clusters", fill = glue("{other_var}")) +
    ggtitle(glue("{other_var} spread over {cluster_group}"))
}

plot_percentage_bar(meta.sepsis, 'pam.clusters', 'sepsis_severity')
```

```{r}
meta.sepsis <- meta.sepsis %>%
  mutate(pam.clusters = "")

generate_heatmap(meta.sepsis, mad.list[[4]], 'er')
```

# ICU validation

```{r}
# Split data into groups
meta.icu <- meta.data %>%
  filter(substr(sample_identifier, 1, 2) != "hc" & 
           patient_location %in% c("icu", 'ward'))

icu.counts <- load_counts('data/de_res/res_sepsis_all.csv', 'gene', meta.icu, 'icu')

# Apply MAD
mad.list <- calculate_mad(icu.counts)
```

```{r}
evaluate_clusters('hc', mad.list, linkage_method = 'ward.D2')
```

```{r}
evaluate_clusters('kmeans', mad.list)
```

```{r}
evaluate_clusters('pam', mad.list, distance = 'manhattan')
```

```{r}
icu.kmeans <- kmeans(mad.list[[4]], centers = 2, iter.max = 100, nstart = 10)
fviz_cluster(icu.kmeans, mad.list[[4]], geom = 'point', ellipse.type = 'convex')
distances <- dist(mad.list[[4]])
fviz_silhouette(silhouette(icu.kmeans$cluster, distances))

icu.pam <- pam(mad.list[[4]], 2, metric = 'manhattan')
fviz_cluster(icu.pam, data = mad.list[[4]], geom = 'point')
fviz_silhouette(icu.pam, print.summary = F)

euclidean_clust <- agnes(dist(mad.list[[4]], 'euclidean'), method = 'ward')
icu.hc <- as.hclust(euclidean_clust)
plot(color_branches(dend_euclidean, k = 2), leaflab="none") # no labels
```

```{r}
cluster_groups_icu <- generate_clusters(icu.hc, icu.pam, icu.kmeans)

meta.icu <- meta.icu %>%
  left_join(cluster_groups_icu, by = 'sample_identifier')
```

```{r}
within_clusters(icu.pam, meta.icu, 0.05)
```

```{r}
icu.significance <- test_significance(meta.icu, 'pam.clusters')
icu.significance
make_table(icu.significance, 'pam')

generate_distributions(meta.icu, icu.significance, 'pam.clusters', 'icu')
```

```{r}
plot_percentage_bar(meta.icu, 'pam.clusters', 'sepsis_severity')
```

```{r}
meta.icu <- meta.icu %>%
  mutate(pam.clusters = case_when(
    pam.clusters == 'one' ~ "ICU-mild",
    pam.clusters == 'two' ~ "ICU-severe"
  )) %>% arrange(pam.clusters)

generate_heatmap(meta.icu, mad.list[[4]], 'icu')
```

# Pathway analysis on Clusters

## ER
```{r}
universe_list <- read.csv("data/ex_gene_ids.csv") %>% distinct(gene)

raw.er.counts <- load_counts('data/counts_raw.csv', 'gene', meta.sepsis, 'er') %>%
  rownames_to_column('gene') %>%  
  semi_join(gene_names, by = 'gene') %>%
  column_to_rownames('gene') %>%
  reordered(meta.sepsis, .)

er.degs <- de_analysis(raw.er.counts, meta.sepsis, 
                   design.element = 'pam.clusters', batch=T,
                   fold_thres = 1, pvalue_thres = 1)

retrieve_sig_degs <- function(result) {
  result %>%
    map(~ filter(.x, de == 'DE')) %>%
    map(~ rownames_to_column(.x, 'gene'))
}

er.degs <- retrieve_sig_degs(er.degs$results)

er_pathway <- pathway_analysis(er.degs, split = T, universe = universe_list)
plot_reactome(er_pathway$reactome_res)
plot_go(er_pathway$go_res)
```

```{r}
load_hc_data <- function(meta, raw_counts, method, type) {
  if (type == 'er') {
    filter_args <- c('er', 'healthy_control')
  } else {
    filter_args <- c('icu', 'ward', 'healthy_control')
  }
  
  meta_hc <- read.csv("data/source/GSE185263_meta_data_N392.csv")
  raw_counts <- raw_counts %>%
    rownames_to_column('gene')

  meta_hc <- meta %>%
    select(sample_identifier, !!sym(method)) %>%
    full_join(meta_hc, by = 'sample_identifier') %>%
    mutate(cluster = ifelse(is.na(!!sym(method)), "hc", !!sym(method))) %>%
    filter(patient_location %in% filter_args)
  
  counts_hc <- read.csv("data/hc_counts.csv") %>%
    rename(gene = ensembl_id) %>%
    inner_join(raw_counts, 'gene') %>%
    column_to_rownames('gene') %>%
    reordered(meta_hc, .)
  
  return(list(counts_hc = counts_hc, meta_hc = meta_hc))
}

hc_er_data <- load_hc_data(meta.sepsis, raw.er.counts, 'pam.clusters', 'er')
er.vs.hc <- de_analysis(hc_er_data$counts_hc, hc_er_data$meta_hc, 
                        design.element = 'cluster', 
                        versus_healthy = T, fold_thres = 1.2)
er.vs.hc.degs <- retrieve_sig_degs(er.vs.hc$results)

pathway_er_hc <- pathway_analysis(er.vs.hc.degs, split = T, universe = universe_list)
plot_reactome(pathway_er_hc$reactome_res)
plot_go(pathway_er_hc$go_res)
```


## ICU
```{r}
raw.icu.counts <- load_counts('data/counts_raw.csv', 'gene', meta.icu, 'icu') %>%
  rownames_to_column('gene') %>%  
  semi_join(gene_names, by = 'gene') %>%
  column_to_rownames('gene') %>%
  reordered(meta.icu, .)

icu.degs <- de_analysis(raw.icu.counts, meta.icu, 
                   design.element = 'pam.clusters', batch=F,
                   fold_thres = 1, pvalue_thres = 1)
icu.degs <- retrieve_sig_degs(icu.degs$results)

icu_pathway <- pathway_analysis(icu.degs, split = T, universe = universe_list)
plot_reactome(icu_pathway$reactome_res)
plot_go(icu_pathway$go_res)
```

```{r}
hc_icu_data <- load_hc_data(meta.icu, raw.icu.counts, 'pam.clusters', 'icu')
icu.vs.hc <- de_analysis(hc_icu_data$counts_hc, hc_icu_data$meta_hc, 
                        design.element = 'cluster', 
                        versus_healthy = T, fold_thres = 1.2)
icu.vs.hc.degs <- retrieve_sig_degs(icu.vs.hc$results)
source('scripts/helper_functions.R')
pathway_icu_hc <- pathway_analysis(icu.vs.hc.degs, split = T, universe = universe_list)
plot_reactome(pathway_icu_hc$reactome_res)
plot_go(pathway_icu_hc$go_res)
```
```{r}
plot_reactome(pathway_icu_hc$reactome_res)
```

# EXTRA
```{r}
library(dbscan)

dbscan_result <- dbscan(mad.list[[4]], eps = 14, minPts = 5)

kNNdistplot(mad.list[[4]], k = 211)
abline(h = 26, lty = 2)
dbscan_result$cluster
df <- as.data.frame(mad.list[[4]])  # Convert your data to a dataframe if it's not already
df$cluster <- as.factor(dbscan_result$cluster)  # Add the cluster assignments to your dataframe

fviz_cluster(dbscan_result, mad.list[[4]], stand = FALSE, frame = FALSE, geom = "point")

# Let's look per group:
visualize_group_boxplots <- function(df=counts, meta=meta.sepsis, x, y, group, both = F) {
  long_format <- df %>% as.data.frame() %>%
    rownames_to_column('gene') %>%
    pivot_longer(cols = -gene, names_to = "sample_identifier", values_to = "counts") %>%
    merge(., meta, by = "sample_identifier")
  
  group_colors <- rainbow(length(unique(long_format[, group])))

  p1 <- ggplot(long_format, aes(x = !!sym(x), y = !!sym(y))) +
    geom_boxplot(aes(fill = as.factor(!!sym(group))), position = position_dodge(0.9)) +
    scale_fill_manual(values = group_colors) + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

  if (both) {
    p2 <- ggplot(long_format, aes(x = !!sym(x), y = !!sym(y))) +
      geom_boxplot(aes(fill = as.factor(!!sym(group))), position = position_dodge(0.9)) +
      facet_wrap(~ gene, scales = "free") +
      scale_fill_manual(values = group_colors) + 
      theme_bw()
  
    gridExtra::grid.arrange(p1, p2, ncol=2)
  } else {
    gridExtra::grid.arrange(p1)
  }
}

# Per gene
lapply(c("hc.clusters", "kmeans.clusters", "pam.clusters"), function(x) {
  for (i in seq(1, nrow(counts), by = 10)) {
    end <- min(i + 9, nrow(counts))
    print(x)
    visualize_group_boxplots(df=counts[i:end, ], x='gene', y='counts', group=x, both=T)
}}
)

# For the groups as a whole!
cluster_groups <- c("pam.clusters")
other_groups <- c("sepsis_severity")
visualize_group_boxplots(x='counts', y="pam.clusters", group="sepsis_severity", both=T)
map(cluster_groups, function(x) {
  map(other_groups, function(x, y) visualize_group_boxplots(x='counts', y=x, group=y), x)
})
```
